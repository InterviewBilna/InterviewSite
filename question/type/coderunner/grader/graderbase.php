<?php
/** The base class for the coderunner Grader classes.
 *  A Grader is called after running all testcases in a sandbox.
 *  Graders have an external name, which appears in the exported .xml question
 *  files for example, and a classname and a filename in which the class is
 *  defined.
 *  to confirm the correctness of the results.
 *  In the simplest subclass, qtype_coderunner_equality_grader, a test result is correct if
 *  the actual and expected outputs are identical after trailing white space
 *  has been removed. More complicated subclasses can, for example, do
 *  things like regular expression testing.
 */

/**
 * @package    qtype
 * @subpackage coderunner
 * @copyright  Richard Lobb, 2012, The University of Canterbury
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/question/type/coderunner/testingoutcome.php');

abstract class qtype_coderunner_grader {
    /** Check all outputs, returning an array of TestResult objects.
     * A TestResult is an object with expected, got, isCorrect and grade fields.
     * 'got' and 'expected' fields are sanitised by replacing embedded
     * control characters with hex equivalents and by limiting their
     * lengths to MAX_STRING_LENGTH.
     */

    const MAX_STRING_LENGTH = 8000;
    
    /**
     * A list of available graders. Keys are the externally known grader names
     * as they appear in the exported questions, values are the associated
     * class names. File names are the same as the class names with the
     * leading qtype_coderunner and all underscores removed.
     * @return array 
     */
    static public function available_graders() {
        return array('EqualityGrader'       => 'qtype_coderunner_equality_grader',
                     'NearEqualityGrader'   => 'qtype_coderunner_near_equality_grader',
                     'RegexGrader'          => 'qtype_coderunner_regex_grader',
                     'TemplateGrader'       => 'qtype_coderunner_template_grader',
                     'CombinatorTemplateGrader' => 'qtype_coderunner_combinator_template_grader'
                );  
    }
    
    
    /**
     * Get the filename containing the given external grader name
     * @param string $externalgradername
     * @return string $filename
     */
    public static function get_filename($extgradername) {
        $graders = self::available_graders();
        $classname = $graders[$extgradername];
        return str_replace('_', '', str_replace('qtype_coderunner_', '', $classname)) . '.php';
    }
    

    /** Called to grade the output generated by a student's code for
     *  a given testcase. Returns a single TestResult object, which
     *  must have called tidy on the expected, output and stdin fields
     *  to limit their lengths.
     */
    public function grade(&$output, &$testcase, $isBad = false) {
       if ($isBad) {
            $outcome = new qtype_coderunner_test_result(
                        qtype_coderunner_grader::tidy($testcase->testcode),
                        $testcase->mark,
                        false,
                        0.0,
                        qtype_coderunner_grader::tidy($testcase->expected),
                        qtype_coderunner_grader::tidy($output),
                        qtype_coderunner_grader::tidy($testcase->stdin),
                        qtype_coderunner_grader::tidy($testcase->extra)
            );
        } else {
            $outcome = $this->grade_known_good($output, $testcase);
        }
        return $outcome;
    }


    abstract function grade_known_good(&$output, &$testCase);

    // Return a cleaned and snipped version of the string s (or null if s is null).
    protected static function tidy($s) {
        if ($s === null) {
            return null;
        } else {
            $cleanS = qtype_coderunner_grader::clean($s);
            return qtype_coderunner_grader::snip($cleanS);
        }
    }

    protected static function clean(&$s) {
        // A copy of $s with trailing blank lines removed and trailing white
        // space from each line removed. Also sanitised by replacing all control
        // chars except newlines with hex equivalents.
        // A newline terminator is added at the end unless the string to be
        // returned is otherwise empty.
        // Used e.g. by the equality grader subclass.
        // This implementation is a bit algorithmically complex because the
        // original implemention, breaking the string into lines using explode,
        // was a hideous memory hog.
        $nls = '';  // Unused line breaks
        $new_s = '';  // Output string
        $spaces = ''; // Unused space characters
        $n = strlen($s);
        for ($i = 0; $i < $n; $i++) {
            $c = $s[$i];
            if ($c === ' ') {
                $spaces .= $c;
            } else if ($c === "\n") {
                $spaces = ''; // Discard spaces before a newline
                $nls .= $c;
            } else {
                if ($c === "\r") {
                    $c = '\\r';
                } else if ($c === "\t") {
                    $c = '\\t';
                } else if ($c < " " || $c > "\x7E") {
                    $c = '\\x' . sprintf("%02x", ord($c));
                }
                $new_s .= $nls . $spaces . $c;
                $spaces = '';
                $nls = '';
            }
        }
        if ($new_s !== '') {
            $new_s .= "\n";
        }
        return $new_s;
    }


    protected static function snip(&$s) {
        // Limit the length of the given string to MAX_STRING_LENGTH by
        // removing the centre of the string, inserting the substring
        // [... snip ... ] in its place
        $snipInsert = ' ...snip... ';
        $len = strlen($s);
        if ($len > qtype_coderunner_grader::MAX_STRING_LENGTH) {
            $lenToRemove = $len - qtype_coderunner_grader::MAX_STRING_LENGTH + strlen($snipInsert);
            $partLength = ($len - $lenToRemove) / 2;
            $firstBit = substr($s, 0, $partLength);
            $lastBit = substr($s, $len - $partLength, $partLength);
            $s = $firstBit . $snipInsert . $lastBit;
        }
        return $s;
    }
}